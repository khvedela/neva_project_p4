/* Automatically generated by p4c-ebpf from main.p4 on Wed Jan 21 10:43:28 2026
 */
#include "main.h"
#include "ebpf_kernel.h"
#include "congestion.h"

enum ebpf_errorCodes {
    NoError,
    PacketTooShort,
    NoMatch,
    StackOutOfBounds,
    HeaderTooShort,
    ParserTimeout,
    ParserInvalidArgument,
};

#define EBPF_MASK(t, w) ((((t)(1)) << (w)) - (t)1)
#define BYTES(w) ((w) / 8)
#define write_partial(a, s, v) do { u8 mask = EBPF_MASK(u8, s); *((u8*)a) = ((*((u8*)a)) & ~mask) | (((v) >> (8 - (s))) & mask); } while (0)
#define write_partial_ex(a, w, s, v) do { *((u8*)a) = ((*((u8*)a)) & ~(EBPF_MASK(u8, w) << s)) | (v << s) ; } while (0)
#define write_byte(base, offset, v) do { *(u8*)((base) + (offset)) = (v); } while (0)
#define PTR_DIFF_BYTES(b, o) (ssize_t)((u8*)(b) - (u8*)(o))

void* memcpy(void* dest, const void* src, size_t num);

#define bpf_trace_message(fmt, ...)

REGISTER_START()
REGISTER_END()

SEC("tc")
int ebpf_filter(SK_BUFF *skb){
    struct Headers headers = {
        .ethernet = {
            .ebpf_valid = 0
        },
        .ipv4 = {
            .ebpf_valid = 0
        },
    };
    enum ebpf_errorCodes ebpf_errorCode = NoError;
    void* ebpf_packetStart = ((void*)(long)skb->data);
    u8* ebpf_headerStart = ebpf_packetStart;
    void* ebpf_packetEnd = ((void*)(long)skb->data_end);
    u8 pass = 0;
    u32 ebpf_zero = 0;
    unsigned char ebpf_byte;
    u32 ebpf_pkt_len = skb->len;

    goto start;
    parse_ipv4: {
/* extract(headers.ipv4) */
        if ((u8*)ebpf_packetEnd < ebpf_headerStart + BYTES(160 + 0)) {
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }

        headers.ipv4.version = (u8)((load_byte(ebpf_headerStart, BYTES(0)) >> 4) & EBPF_MASK(u8, 4));
        headers.ipv4.ihl = (u8)((load_byte(ebpf_headerStart, BYTES(4))) & EBPF_MASK(u8, 4));
        headers.ipv4.diffserv = (u8)((load_byte(ebpf_headerStart, BYTES(8))));
        headers.ipv4.totalLen = (u16)((load_half(ebpf_headerStart, BYTES(16))));
        headers.ipv4.identification = (u16)((load_half(ebpf_headerStart, BYTES(32))));
        headers.ipv4.flags = (u8)((load_byte(ebpf_headerStart, BYTES(48)) >> 5) & EBPF_MASK(u8, 3));
        headers.ipv4.fragOffset = (u16)((load_half(ebpf_headerStart, BYTES(51))) & EBPF_MASK(u16, 13));
        headers.ipv4.ttl = (u8)((load_byte(ebpf_headerStart, BYTES(64))));
        headers.ipv4.protocol = (u8)((load_byte(ebpf_headerStart, BYTES(72))));
        headers.ipv4.hdrChecksum = (u16)((load_half(ebpf_headerStart, BYTES(80))));
        headers.ipv4.srcAddr = (u32)((load_word(ebpf_headerStart, BYTES(96))));
        headers.ipv4.dstAddr = (u32)((load_word(ebpf_headerStart, BYTES(128))));

        headers.ipv4.ebpf_valid = 1;
        ebpf_headerStart += BYTES(160);

;
         goto accept;
    }
    start: {
/* extract(headers.ethernet) */
        if ((u8*)ebpf_packetEnd < ebpf_headerStart + BYTES(112 + 0)) {
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }

        headers.ethernet.dstAddr = (u64)((load_dword(ebpf_headerStart, BYTES(0)) >> 16) & EBPF_MASK(u64, 48));
        headers.ethernet.srcAddr = (u64)((load_dword(ebpf_headerStart, BYTES(48)) >> 16) & EBPF_MASK(u64, 48));
        headers.ethernet.etherType = (u16)((load_half(ebpf_headerStart, BYTES(96))));

        headers.ethernet.ebpf_valid = 1;
        ebpf_headerStart += BYTES(112);

;
        u16 select_0;
                select_0 = headers.ethernet.etherType;
        if (select_0 == 0x800)goto parse_ipv4;
        if ((select_0 & 0x0) == (0x0 & 0x0))goto accept;
        else goto reject;
    }

    reject: {
        return TC_ACT_SHOT;
    }

    accept:
    {
        u8 hit;
        u8 should_drop_0;
        {
if (/* headers.ipv4.isValid() */
            headers.ipv4.ebpf_valid) {
/* check_congestion(should_drop_0) */
check_congestion(&should_drop_0);
;
                if (should_drop_0) {
                                        pass = false;                }

                else {
                                        pass = true;                }

            }
            else {
                                pass = true;            }

        }
    }
    ebpf_end:
    if (pass)
        return TC_ACT_OK;
    else
        return TC_ACT_SHOT;
}
char _license[] SEC("license") = "GPL";
